\documentclass[12pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{float}
\usepackage{array}
\usepackage{longtable}
\usepackage{booktabs}

% Configuration de la page
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Mini-Projet BI - SmartWallet}
\fancyhead[R]{\thepage}
\fancyfoot[C]{√âcole Polytechnique de Sousse - 2025/2026}

% Configuration des couleurs
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{primarycolor}{RGB}{0, 102, 204}

% Configuration des listings (code)
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Mini-Projet BI},
    pdfpagemode=FullScreen,
}

% Commandes personnalis√©es
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}

% Page de garde
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\huge\bfseries Mini-Projet Data Analytics \& Business Intelligence\par}
    \vspace{1cm}
    {\Large SmartWallet - Plateforme d'Analyse Financi√®re Intelligente\par}
    \vspace{2cm}
    
    \includegraphics[width=0.3\textwidth]{logo_eps.png}
    \vspace{1cm}
    
    {\Large\itshape Pr√©sent√© par :\par}
    {\large Nom Pr√©nom 1\par}
    {\large Nom Pr√©nom 2\par}
    \vspace{1cm}
    
    {\Large Encadr√© par :\par}
    {\large Dr-Ing. Nedya BOUFARES\par}
    \vspace{2cm}
    
    {\large √âcole Polytechnique de Sousse\par}
    {\large 5√®me Ann√©e Ing√©nierie Informatique\par}
    {\large Ann√©e Universitaire 2025-2026\par}
    
    \vfill
    
    {\large \today\par}
\end{titlepage}

% Table des mati√®res
\tableofcontents
\newpage

% Liste des figures
\listoffigures
\newpage

% Liste des tableaux
\listoftables
\newpage

%=============================================================================
% INTRODUCTION
%=============================================================================
\section{Introduction}

\subsection{Contexte du Projet}
Ce mini-projet s'inscrit dans le cadre du module \textbf{Data Analytics and Business Intelligence} destin√© aux √©tudiants de 5√®me ann√©e d'ing√©nierie en informatique. Il vise √† consolider les comp√©tences en analyse de donn√©es, ETL, mod√©lisation d√©cisionnelle, data visualisation et int√©gration BI dans une application existante.

\subsection{Objectifs}
Les principaux objectifs de ce projet sont :

\begin{itemize}[leftmargin=2cm]
    \item[\checkmark] Mettre en ≈ìuvre un processus BI complet √† partir de donn√©es existantes
    \item[\checkmark] Concevoir et impl√©menter un processus ETL (Extract, Transform, Load)
    \item[\checkmark] Construire un entrep√¥t de donn√©es (Data Warehouse) bas√© sur un mod√®le en √©toile
    \item[\checkmark] Exploiter les outils Power BI pour l'analyse et la visualisation des donn√©es
    \item[\checkmark] Int√©grer les r√©sultats d√©cisionnels dans une application MERN
\end{itemize}

\subsection{Pr√©sentation de SmartWallet}
\textbf{SmartWallet} est une plateforme de gestion financi√®re personnelle d√©velopp√©e avec la stack MERN (MongoDB, Express.js, React, Node.js). Elle permet aux utilisateurs de :

\begin{itemize}
    \item G√©rer leurs comptes bancaires
    \item Suivre leurs transactions (revenus et d√©penses)
    \item Cr√©er et suivre des budgets
    \item D√©finir des objectifs d'√©pargne
    \item Collaborer sur des budgets partag√©s
\end{itemize}

L'objectif de ce projet BI est d'enrichir SmartWallet avec des capacit√©s d'analyse d√©cisionnelle avanc√©es pour offrir aux utilisateurs des insights sur leurs habitudes financi√®res.

%=============================================================================
% ARCHITECTURE BI GLOBALE
%=============================================================================
\section{Architecture BI Globale}

\subsection{Vue d'Ensemble}

L'architecture Business Intelligence de SmartWallet suit un processus classique de BI moderne, allant de la source op√©rationnelle (MongoDB) jusqu'√† la restitution finale dans l'application MERN.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        node distance=2cm,
        box/.style={rectangle, draw, fill=blue!20, text width=3cm, text centered, rounded corners, minimum height=1cm},
        arrow/.style={->, >=stealth, thick}
    ]
        % Nodes
        \node[box] (mongo) {MongoDB\\(Base Op√©rationnelle)};
        \node[box, below of=mongo] (etl) {Processus ETL\\(Python)};
        \node[box, below of=etl] (dw) {Data Warehouse\\(MySQL)};
        \node[box, below of=dw] (powerbi) {Power BI\\(Dashboards)};
        \node[box, below of=powerbi] (mern) {Application MERN\\(Int√©gration)};
        
        % Arrows
        \draw[arrow] (mongo) -- (etl) node[midway, right] {Extraction};
        \draw[arrow] (etl) -- (dw) node[midway, right] {Chargement};
        \draw[arrow] (dw) -- (powerbi) node[midway, right] {Connexion};
        \draw[arrow] (powerbi) -- (mern) node[midway, right] {Embed};
    \end{tikzpicture}
    \caption{Architecture BI de SmartWallet}
    \label{fig:architecture}
\end{figure}

\subsection{Composants de l'Architecture}

\subsubsection{Couche Source (MongoDB)}
\begin{itemize}
    \item \textbf{R√¥le} : Base de donn√©es op√©rationnelle de l'application MERN
    \item \textbf{Technologie} : MongoDB (NoSQL, orient√© documents)
    \item \textbf{Collections principales} : users, categories, accounts, transactions, budgets, savingsgoals
    \item \textbf{Volume} : Environ 6000 transactions sur 12 mois pour 30 utilisateurs
\end{itemize}

\subsubsection{Couche ETL (Python)}
\begin{itemize}
    \item \textbf{R√¥le} : Extraction, transformation et chargement des donn√©es
    \item \textbf{Technologie} : Python avec PyMongo, Pandas, MySQL Connector
    \item \textbf{Fr√©quence} : Quotidienne (automatis√©e via cron)
\end{itemize}

\subsubsection{Couche Stockage (Data Warehouse)}
\begin{itemize}
    \item \textbf{R√¥le} : Entrep√¥t de donn√©es optimis√© pour l'analyse
    \item \textbf{Technologie} : MySQL (XAMPP)
    \item \textbf{Mod√©lisation} : Sch√©ma en √©toile avec 1 table de faits et 4 tables de dimensions
\end{itemize}

\subsubsection{Couche Analyse (Power BI)}
\begin{itemize}
    \item \textbf{R√¥le} : Visualisation et analyse des donn√©es
    \item \textbf{Technologie} : Power BI Desktop + Power BI Service
    \item \textbf{Fonctionnalit√©s} : Dashboards interactifs, mesures DAX, filtres dynamiques
\end{itemize}

\subsubsection{Couche Pr√©sentation (MERN)}
\begin{itemize}
    \item \textbf{R√¥le} : Int√©gration des dashboards dans l'application web
    \item \textbf{Technologie} : React avec powerbi-client-react
    \item \textbf{Mode} : Embedding via Power BI Service
\end{itemize}

%=============================================================================
% SOURCES DE DONN√âES
%=============================================================================
\section{Sources de Donn√©es}

\subsection{Base de Donn√©es MongoDB}

La base de donn√©es op√©rationnelle MongoDB \code{smartwallet} contient les collections suivantes :

\begin{table}[H]
\centering
\begin{tabular}{|l|l|c|}
\hline
\textbf{Collection} & \textbf{Description} & \textbf{Volume} \\
\hline
users & Informations des utilisateurs & 30 \\
categories & Cat√©gories de transactions & 13 \\
accounts & Comptes bancaires & 60 \\
transactions & Transactions financi√®res & 6000 \\
budgets & Budgets mensuels & 30 \\
savingsgoals & Objectifs d'√©pargne & 60 \\
\hline
\end{tabular}
\caption{Collections MongoDB}
\label{tab:collections}
\end{table}

\subsection{G√©n√©ration des Donn√©es de Test}

Pour alimenter la base de donn√©es avec des donn√©es r√©alistes, nous avons d√©velopp√© un script de seed utilisant la biblioth√®que \textbf{Faker.js}.

\subsubsection{Configuration du Seed}
\begin{lstlisting}[language=JavaScript, caption=Configuration du seed de donn√©es]
const CONFIG = {
  USERS_COUNT: 30,              // Nombre d'utilisateurs
  ACCOUNTS_PER_USER: 2,         // Comptes par utilisateur
  TRANSACTIONS_PER_USER: 200,   // Transactions sur 12 mois
  BUDGETS_PER_USER: 1,
  SAVINGS_GOALS_PER_USER: 2
};
\end{lstlisting}

\subsubsection{Cat√©gories Pr√©d√©finies}

Les cat√©gories de transactions incluent :

\begin{multicols}{2}
\begin{itemize}
    \item Alimentation
    \item Transport
    \item Logement
    \item Loisirs
    \item Shopping
    \item Sant√©
    \item √âducation
    \item Restaurants
    \item Factures
    \item Abonnements
    \item Salaire (revenu)
    \item Freelance (revenu)
    \item Investissements (revenu)
\end{itemize}
\end{multicols}

\subsection{Caract√©ristiques des Donn√©es}

\begin{itemize}
    \item \textbf{P√©riode} : 12 mois (de janvier 2024 √† janvier 2025)
    \item \textbf{Distribution} : 80\% de d√©penses, 20\% de revenus (distribution r√©aliste)
    \item \textbf{Montants} : Variables selon la cat√©gorie (ex: Logement 200-800 TND, Alimentation 10-150 TND)
    \item \textbf{R√©currence} : 15\% de transactions r√©currentes (salaire, loyer, abonnements)
\end{itemize}

%=============================================================================
% PROCESSUS ETL
%=============================================================================
\section{Processus ETL}

\subsection{Vue d'Ensemble du Processus}

Le processus ETL est impl√©ment√© en Python et se d√©compose en trois phases principales :

\begin{enumerate}
    \item \textbf{Extract} : Extraction des donn√©es depuis MongoDB
    \item \textbf{Transform} : Nettoyage, transformation et enrichissement
    \item \textbf{Load} : Chargement dans le Data Warehouse MySQL
\end{enumerate}

\subsection{Architecture du Projet ETL}

\begin{lstlisting}[caption=Structure du projet ETL]
etl/
|-- config/
|   |-- __init__.py
|   `-- database.py              # Connexions MongoDB + MySQL
|-- extractors/
|   |-- __init__.py
|   `-- mongo_extractor.py       # Extraction depuis MongoDB
|-- transformers/
|   |-- __init__.py
|   `-- data_transformer.py      # Transformations
|-- loaders/
|   |-- __init__.py
|   `-- warehouse_loader.py      # Chargement dans DW
|-- utils/
|   |-- __init__.py
|   `-- helpers.py
|-- .env                          # Variables d'environnement
|-- requirements.txt              # Dependances Python
`-- main_etl.py                   # Script principal
\end{lstlisting}

\subsection{Phase 1 : Extraction (Extract)}

\subsubsection{Connexion aux Sources}

\begin{lstlisting}[language=Python, caption=Connexion MongoDB et MySQL]
import pymongo
import mysql.connector
from dotenv import load_dotenv

class DatabaseConnections:
    def __init__(self):
        # Connexion MongoDB
        self.mongo_client = pymongo.MongoClient(
            os.getenv('MONGO_URI')
        )
        self.mongo_db = self.mongo_client[
            os.getenv('MONGO_DB_NAME')
        ]
        
        # Connexion MySQL
        self.mysql_conn = mysql.connector.connect(
            host=os.getenv('MYSQL_HOST'),
            user=os.getenv('MYSQL_USER'),
            password=os.getenv('MYSQL_PASSWORD'),
            database=os.getenv('MYSQL_DB_NAME')
        )
\end{lstlisting}

\subsubsection{Extraction des Donn√©es}

Les donn√©es sont extraites depuis MongoDB en utilisant PyMongo :

\begin{lstlisting}[language=Python, caption=Extraction des transactions]
def extract_transactions(self):
    """Extraire les transactions avec jointures"""
    pipeline = [
        {
            '$lookup': {
                'from': 'users',
                'localField': 'user',
                'foreignField': '_id',
                'as': 'user_data'
            }
        },
        {
            '$lookup': {
                'from': 'categories',
                'localField': 'category',
                'foreignField': '_id',
                'as': 'category_data'
            }
        },
        {
            '$lookup': {
                'from': 'accounts',
                'localField': 'account',
                'foreignField': '_id',
                'as': 'account_data'
            }
        }
    ]
    
    transactions = list(
        self.db.transactions.aggregate(pipeline)
    )
    return pd.DataFrame(transactions)
\end{lstlisting}

\subsection{Phase 2 : Transformation (Transform)}

\subsubsection{Nettoyage des Donn√©es}

Les transformations appliqu√©es incluent :

\begin{itemize}
    \item \textbf{Suppression des doublons} : Bas√©e sur les cl√©s primaires
    \item \textbf{Gestion des valeurs manquantes} : Remplacement par des valeurs par d√©faut
    \item \textbf{Conversion des types} : ObjectId ‚Üí String, Dates ‚Üí Format standard
    \item \textbf{Normalisation} : Uniformisation des formats (devises, noms)
\end{itemize}

\begin{lstlisting}[language=Python, caption=Nettoyage des utilisateurs]
def clean_users(df_users):
    # Supprimer les doublons
    df_users = df_users.drop_duplicates(subset=['user_id'])
    
    # Gerer les valeurs manquantes
    df_users['full_name'].fillna('Unknown', inplace=True)
    df_users['email'].fillna(
        'no-email@example.com', 
        inplace=True
    )
    
    # Extraire la date d'inscription
    df_users['registration_date'] = pd.to_datetime(
        df_users['createdAt']
    ).dt.date
    
    return df_users
\end{lstlisting}

\subsubsection{Enrichissement des Donn√©es}

\begin{lstlisting}[language=Python, caption=Creation de la cle de date]
def transform_transactions(df_transactions):
    # Creer la cle de date (YYYYMMDD)
    df_transactions['date_key'] = pd.to_datetime(
        df_transactions['date']
    ).dt.strftime('%Y%m%d').astype(int)
    
    # Determiner type (revenu/depense)
    df_transactions['is_income'] = (
        df_transactions['type'] == 'income'
    )
    
    return df_transactions
\end{lstlisting}

\subsubsection{G√©n√©ration de la Dimension Temps}

\begin{lstlisting}[language=Python, caption=Generation dimension temps]
def generate_date_dimension(
    start_date='2020-01-01', 
    end_date='2030-12-31'
):
    dates = pd.date_range(
        start=start_date, 
        end=end_date, 
        freq='D'
    )
    
    df_date = pd.DataFrame({
        'date_key': dates.strftime('%Y%m%d').astype(int),
        'full_date': dates.date,
        'day': dates.day,
        'month': dates.month,
        'year': dates.year,
        'day_of_week': dates.dayofweek,
        'day_name': dates.day_name(),
        'month_name': dates.month_name(),
        'quarter': dates.quarter,
        'is_weekend': dates.dayofweek.isin([5, 6])
    })
    
    return df_date
\end{lstlisting}

\subsection{Phase 3 : Chargement (Load)}

\subsubsection{Strat√©gie de Chargement}

Nous utilisons une strat√©gie de chargement \textbf{upsert} (update or insert) :

\begin{lstlisting}[language=Python, caption=Chargement des dimensions]
def load_dim_user(self, df_users):
    query = """
    INSERT INTO dim_user (
        user_id, full_name, email, registration_date
    )
    VALUES (%s, %s, %s, %s)
    ON DUPLICATE KEY UPDATE
        full_name = VALUES(full_name),
        email = VALUES(email)
    """
    
    data = df_users[[
        'user_id', 'full_name', 
        'email', 'registration_date'
    ]].values.tolist()
    
    self.cursor.executemany(query, data)
    self.connection.commit()
\end{lstlisting}

\subsubsection{Chargement de la Table de Faits}

\begin{lstlisting}[language=Python, caption=Chargement de fact\_transaction]
def load_fact_transaction(self, df_transactions):
    # Recuperer les mappings des cles
    self.cursor.execute(
        "SELECT user_id, user_key FROM dim_user"
    )
    user_mapping = {
        row[0]: row[1] 
        for row in self.cursor.fetchall()
    }
    
    # Mapper les cles etrangeres
    df_transactions['user_key'] = (
        df_transactions['user_id'].map(user_mapping)
    )
    
    query = """
    INSERT INTO fact_transaction (
        user_key, category_key, account_key, date_key,
        amount, is_income, transaction_count
    )
    VALUES (%s, %s, %s, %s, %s, %s, %s)
    """
    
    self.cursor.executemany(query, data_list)
    self.connection.commit()
\end{lstlisting}

\subsection{M√©tadonn√©es ETL}

Pour suivre l'ex√©cution du processus ETL :

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Champ} & \textbf{Type} & \textbf{Description} \\
\hline
etl\_id & INT & Identifiant unique \\
last\_run & TIMESTAMP & Date d'ex√©cution \\
status & VARCHAR(50) & success/failed \\
records\_processed & INT & Nb de records \\
error\_message & TEXT & Message d'erreur \\
\hline
\end{tabular}
\caption{Table etl\_metadata}
\label{tab:etl-metadata}
\end{table}

\subsection{R√©sultats de l'Ex√©cution ETL}

\begin{tcolorbox}[colback=green!5!white, colframe=green!75!black, title=R√©sultat ETL]
\begin{verbatim}
============================================================
üöÄ PROCESSUS ETL - SmartWallet Data Warehouse
============================================================
‚úÖ MongoDB connect√©
‚úÖ MySQL connect√©

üì¶ PHASE 1: EXTRACTION
   ‚úÖ Utilisateurs extraits: 30
   ‚úÖ Cat√©gories extraites: 13
   ‚úÖ Comptes extraits: 60
   ‚úÖ Transactions extraites: 6000

üîÑ PHASE 2: TRANSFORMATION
   ‚úÖ Utilisateurs transform√©s: 30
   ‚úÖ Cat√©gories transform√©es: 13
   ‚úÖ Comptes transform√©s: 60
   ‚úÖ Transactions transform√©es: 6000
   ‚úÖ Dimension temps g√©n√©r√©e: 4018 jours

üì• PHASE 3: CHARGEMENT
   ‚úÖ 4018 dates charg√©es dans dim_date
   ‚úÖ 30 utilisateurs charg√©s dans dim_user
   ‚úÖ 13 cat√©gories charg√©es dans dim_category
   ‚úÖ 60 comptes charg√©s dans dim_account
   ‚úÖ 6000 transactions charg√©es dans fact_transaction

‚úÖ ETL TERMIN√â AVEC SUCC√àS
‚è±Ô∏è  Dur√©e totale: 8.35 secondes
\end{verbatim}
\end{tcolorbox}

%=============================================================================
% DATA WAREHOUSE
%=============================================================================
\section{Data Warehouse}

\subsection{Choix du SGBD}

Nous avons opt√© pour \textbf{MySQL} (via XAMPP) pour les raisons suivantes :

\begin{itemize}
    \item Compatibilit√© native avec Power BI
    \item Facilit√© de d√©ploiement local (XAMPP)
    \item Performance suffisante pour notre volume de donn√©es
    \item Simplicit√© d'administration
\end{itemize}

\subsection{Mod√©lisation en √âtoile}

\subsubsection{Architecture du Mod√®le}

Le Data Warehouse suit une architecture en \textbf{√©toile} (star schema) compos√©e de :
\begin{itemize}
    \item \textbf{1 table de faits} : \code{fact\_transaction}
    \item \textbf{4 tables de dimensions} : \code{dim\_user}, \code{dim\_category}, \code{dim\_account}, \code{dim\_date}
\end{itemize}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[
        fact/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum width=3cm, minimum height=1.5cm},
        dim/.style={rectangle, draw=blue!60, fill=blue!5, very thick, minimum width=2.5cm, minimum height=1cm},
        arrow/.style={->, >=stealth, thick}
    ]
        % Fact table
        \node[fact] (fact) at (0,0) {\textbf{FACT\_TRANSACTION}};
        
        % Dimensions
        \node[dim] (user) at (-4,3) {DIM\_USER};
        \node[dim] (category) at (4,3) {DIM\_CATEGORY};
        \node[dim] (account) at (-4,-3) {DIM\_ACCOUNT};
        \node[dim] (date) at (4,-3) {DIM\_DATE};
        
        % Arrows
        \draw[arrow] (user) -- (fact);
        \draw[arrow] (category) -- (fact);
        \draw[arrow] (account) -- (fact);
        \draw[arrow] (date) -- (fact);
    \end{tikzpicture}
    \caption{Mod√®le en √©toile du Data Warehouse}
    \label{fig:star-schema}
\end{figure}

\subsection{Description des Tables}

\subsubsection{Table de Faits : fact\_transaction}

La table de faits contient les transactions avec les mesures et les cl√©s √©trang√®res vers les dimensions.

\begin{longtable}{|l|l|p{6cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
\endfirsthead
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
\endhead
transaction\_key & BIGINT & Cl√© primaire (auto-increment) \\
user\_key & INT & FK vers dim\_user \\
category\_key & INT & FK vers dim\_category \\
account\_key & INT & FK vers dim\_account \\
date\_key & INT & FK vers dim\_date \\
amount & DECIMAL(15,2) & Montant de la transaction \\
is\_income & BOOLEAN & TRUE si revenu, FALSE si d√©pense \\
transaction\_count & INT & Toujours 1 (pour COUNT) \\
\hline
\caption{Structure de fact\_transaction}
\label{tab:fact-transaction}
\end{longtable}

\subsubsection{Dimension : dim\_user}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
user\_key & INT & Cl√© primaire \\
user\_id & VARCHAR(50) & ID MongoDB (unique) \\
full\_name & VARCHAR(255) & Nom complet \\
email & VARCHAR(255) & Email \\
registration\_date & DATE & Date d'inscription \\
country & VARCHAR(100) & Pays \\
created\_at & TIMESTAMP & Date de cr√©ation \\
\hline
\end{tabular}
\caption{Structure de dim\_user}
\label{tab:dim-user}
\end{table}

\subsubsection{Dimension : dim\_category}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
category\_key & INT & Cl√© primaire \\
category\_id & VARCHAR(50) & ID MongoDB (unique) \\
category\_name & VARCHAR(255) & Nom cat√©gorie \\
category\_type & VARCHAR(50) & expense/income \\
icon & VARCHAR(50) & Emoji/ic√¥ne \\
created\_at & TIMESTAMP & Date de cr√©ation \\
\hline
\end{tabular}
\caption{Structure de dim\_category}
\label{tab:dim-category}
\end{table}

\subsubsection{Dimension : dim\_account}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{5cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
account\_key & INT & Cl√© primaire \\
account\_id & VARCHAR(50) & ID MongoDB (unique) \\
account\_name & VARCHAR(255) & Nom du compte \\
account\_type & VARCHAR(50) & Courant, √âpargne, etc. \\
institution & VARCHAR(255) & Nom de la banque \\
currency & VARCHAR(10) & TND, EUR, USD \\
is\_active & BOOLEAN & Compte actif/inactif \\
created\_at & TIMESTAMP & Date de cr√©ation \\
\hline
\end{tabular}
\caption{Structure de dim\_account}
\label{tab:dim-account}
\end{table}

\subsubsection{Dimension : dim\_date}

La dimension temps couvre la p√©riode 2020-2030 (4018 jours).

\begin{table}[H]
\centering
\begin{tabular}{|l|l|p{6cm}|}
\hline
\textbf{Colonne} & \textbf{Type} & \textbf{Description} \\
\hline
date\_key & INT & Cl√© primaire (YYYYMMDD) \\
full\_date & DATE & Date compl√®te (unique) \\
day & INT & Jour du mois (1-31) \\
month & INT & Mois (1-12) \\
year & INT & Ann√©e \\
day\_of\_week & INT & Jour semaine (0-6) \\
day\_name & VARCHAR(20) & Nom du jour \\
month\_name & VARCHAR(20) & Nom du mois \\
quarter & INT & Trimestre (1-4) \\
is\_weekend & BOOLEAN & TRUE si samedi/dimanche \\
\hline
\end{tabular}
\caption{Structure de dim\_date}
\label{tab:dim-date}
\end{table}

\subsection{Script SQL de Cr√©ation}

\begin{lstlisting}[language=SQL, caption=Initialisation du Data Warehouse]
-- Script d'initialisation du Data Warehouse SmartWallet
CREATE DATABASE IF NOT EXISTS smartwallet_dw;
USE smartwallet_dw;

-- Dimension Utilisateur
CREATE TABLE IF NOT EXISTS dim_user (
    user_key INT AUTO_INCREMENT PRIMARY KEY,
    user_id VARCHAR(50) UNIQUE NOT NULL,
    full_name VARCHAR(100),
    email VARCHAR(100),
    registration_date DATE,
    INDEX (user_id)
) ENGINE=InnoDB;

-- Table de Faits : Transactions
CREATE TABLE IF NOT EXISTS fact_transaction (
    fact_key INT AUTO_INCREMENT PRIMARY KEY,
    user_key INT NOT NULL,
    category_key INT NOT NULL,
    account_key INT NOT NULL,
    date_key INT NOT NULL,
    amount DECIMAL(15, 2) NOT NULL,
    is_income BOOLEAN NOT NULL,
    FOREIGN KEY (user_key) REFERENCES dim_user(user_key)
) ENGINE=InnoDB;
\end{lstlisting}

%=============================================================================
% ANALYSE ET VISUALISATION POWER BI
%=============================================================================
\section{Analyse et Visualisation Power BI}

\subsection{Mod√©lisation des Donn√©es}
Dans Power BI, nous avons √©tabli des relations de type **1:N** entre les tables de dimensions (\code{dim\_user}, \code{dim\_category}, \code{dim\_account}, \code{dim\_date}) et la table de faits (\code{fact\_transaction}). Cette structure permet des filtres crois√©s fluides et performants.

\subsection{Mesures DAX Avanc√©es}
Pour enrichir l'analyse, plusieurs mesures DAX ont √©t√© cr√©√©es :
\begin{itemize}
    \item \textbf{Total D√©penses} : \code{SUMX(FILTER(fact\_transaction, [is\_income]=0), [amount])}
    \item \textbf{Total Revenus} : \code{SUMX(FILTER(fact\_transaction, [is\_income]=1), [amount])}
    \item \textbf{Solde Moyen} : \code{AVERAGEX(VALUES(dim\_date[month]), [Total Revenus] - [Total D√©penses])}
\end{itemize}

%=============================================================================
% INT√âGRATION MERN
%=============================================================================
\section{Int√©gration dans l'Application MERN}

L'int√©gration est r√©alis√©e via un composant React d√©di√© \code{DashboardBI.jsx}. Ce composant encapsule le rapport Power BI publi√© sur le service Cloud √† l'aide d'une \code{iframe} s√©curis√©e, parfaitement int√©gr√©e au design "Glassmorphism" de l'application.

\begin{lstlisting}[language=JavaScript, caption=Int√©gration du rapport dans React]
const DashboardBI = () => {
    const biEmbedUrl = "https://app.powerbi.com/view?r=...";
    return (
        <div className="bi-dashboard-container">
            <div className="bi-frame-wrapper">
                <iframe
                    title="SmartWallet BI Analytics"
                    width="100%"
                    height="600"
                    src={biEmbedUrl}
                    frameBorder="0"
                    allowFullScreen={true}
                ></iframe>
            </div>
        </div>
    );
};
\end{lstlisting}

%=============================================================================
% CONCLUSION
%=============================================================================
\section{Conclusion}
Le projet SmartWallet BI d√©montre avec succ√®s comment une approche structur√©e de la donn√©e permet d'apporter une valeur ajout√©e significative √† une application MERN. La s√©paration entre base op√©rationnelle (MongoDB) et analytique (MySQL) garantit des performances optimales, tandis que Power BI offre une puissance de visualisation d√©cisionnelle de haut niveau pour l'utilisateur final.

\end{document}